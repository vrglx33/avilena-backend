// Code generated by Prisma (prisma@1.20.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  cognitiveTest: (where?: CognitiveTestWhereInput) => Promise<boolean>;
  cognitiveTestQuestion: (
    where?: CognitiveTestQuestionWhereInput
  ) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  forum: (where?: ForumWhereInput) => Promise<boolean>;
  questionType: (where?: QuestionTypeWhereInput) => Promise<boolean>;
  response: (where?: ResponseWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userDiagnosis: (where?: UserDiagnosisWhereInput) => Promise<boolean>;
  userResponse: (where?: UserResponseWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  cognitiveTest: (where: CognitiveTestWhereUniqueInput) => CognitiveTestPromise;
  cognitiveTests: (
    args?: {
      where?: CognitiveTestWhereInput;
      orderBy?: CognitiveTestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CognitiveTest>;
  cognitiveTestsConnection: (
    args?: {
      where?: CognitiveTestWhereInput;
      orderBy?: CognitiveTestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CognitiveTestConnectionPromise;
  cognitiveTestQuestion: (
    where: CognitiveTestQuestionWhereUniqueInput
  ) => CognitiveTestQuestionPromise;
  cognitiveTestQuestions: (
    args?: {
      where?: CognitiveTestQuestionWhereInput;
      orderBy?: CognitiveTestQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CognitiveTestQuestion>;
  cognitiveTestQuestionsConnection: (
    args?: {
      where?: CognitiveTestQuestionWhereInput;
      orderBy?: CognitiveTestQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CognitiveTestQuestionConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  forum: (where: ForumWhereUniqueInput) => ForumPromise;
  forums: (
    args?: {
      where?: ForumWhereInput;
      orderBy?: ForumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Forum>;
  forumsConnection: (
    args?: {
      where?: ForumWhereInput;
      orderBy?: ForumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ForumConnectionPromise;
  questionType: (where: QuestionTypeWhereUniqueInput) => QuestionTypePromise;
  questionTypes: (
    args?: {
      where?: QuestionTypeWhereInput;
      orderBy?: QuestionTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<QuestionType>;
  questionTypesConnection: (
    args?: {
      where?: QuestionTypeWhereInput;
      orderBy?: QuestionTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => QuestionTypeConnectionPromise;
  response: (where: ResponseWhereUniqueInput) => ResponsePromise;
  responses: (
    args?: {
      where?: ResponseWhereInput;
      orderBy?: ResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Response>;
  responsesConnection: (
    args?: {
      where?: ResponseWhereInput;
      orderBy?: ResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ResponseConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userDiagnosis: (where: UserDiagnosisWhereUniqueInput) => UserDiagnosisPromise;
  userDiagnoses: (
    args?: {
      where?: UserDiagnosisWhereInput;
      orderBy?: UserDiagnosisOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserDiagnosis>;
  userDiagnosesConnection: (
    args?: {
      where?: UserDiagnosisWhereInput;
      orderBy?: UserDiagnosisOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserDiagnosisConnectionPromise;
  userResponse: (where: UserResponseWhereUniqueInput) => UserResponsePromise;
  userResponses: (
    args?: {
      where?: UserResponseWhereInput;
      orderBy?: UserResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserResponse>;
  userResponsesConnection: (
    args?: {
      where?: UserResponseWhereInput;
      orderBy?: UserResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserResponseConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCognitiveTest: (data: CognitiveTestCreateInput) => CognitiveTestPromise;
  updateCognitiveTest: (
    args: {
      data: CognitiveTestUpdateInput;
      where: CognitiveTestWhereUniqueInput;
    }
  ) => CognitiveTestPromise;
  upsertCognitiveTest: (
    args: {
      where: CognitiveTestWhereUniqueInput;
      create: CognitiveTestCreateInput;
      update: CognitiveTestUpdateInput;
    }
  ) => CognitiveTestPromise;
  deleteCognitiveTest: (
    where: CognitiveTestWhereUniqueInput
  ) => CognitiveTestPromise;
  deleteManyCognitiveTests: (
    where?: CognitiveTestWhereInput
  ) => BatchPayloadPromise;
  createCognitiveTestQuestion: (
    data: CognitiveTestQuestionCreateInput
  ) => CognitiveTestQuestionPromise;
  updateCognitiveTestQuestion: (
    args: {
      data: CognitiveTestQuestionUpdateInput;
      where: CognitiveTestQuestionWhereUniqueInput;
    }
  ) => CognitiveTestQuestionPromise;
  updateManyCognitiveTestQuestions: (
    args: {
      data: CognitiveTestQuestionUpdateManyMutationInput;
      where?: CognitiveTestQuestionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCognitiveTestQuestion: (
    args: {
      where: CognitiveTestQuestionWhereUniqueInput;
      create: CognitiveTestQuestionCreateInput;
      update: CognitiveTestQuestionUpdateInput;
    }
  ) => CognitiveTestQuestionPromise;
  deleteCognitiveTestQuestion: (
    where: CognitiveTestQuestionWhereUniqueInput
  ) => CognitiveTestQuestionPromise;
  deleteManyCognitiveTestQuestions: (
    where?: CognitiveTestQuestionWhereInput
  ) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createForum: (data: ForumCreateInput) => ForumPromise;
  updateForum: (
    args: { data: ForumUpdateInput; where: ForumWhereUniqueInput }
  ) => ForumPromise;
  updateManyForums: (
    args: { data: ForumUpdateManyMutationInput; where?: ForumWhereInput }
  ) => BatchPayloadPromise;
  upsertForum: (
    args: {
      where: ForumWhereUniqueInput;
      create: ForumCreateInput;
      update: ForumUpdateInput;
    }
  ) => ForumPromise;
  deleteForum: (where: ForumWhereUniqueInput) => ForumPromise;
  deleteManyForums: (where?: ForumWhereInput) => BatchPayloadPromise;
  createQuestionType: (data: QuestionTypeCreateInput) => QuestionTypePromise;
  updateQuestionType: (
    args: { data: QuestionTypeUpdateInput; where: QuestionTypeWhereUniqueInput }
  ) => QuestionTypePromise;
  updateManyQuestionTypes: (
    args: {
      data: QuestionTypeUpdateManyMutationInput;
      where?: QuestionTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertQuestionType: (
    args: {
      where: QuestionTypeWhereUniqueInput;
      create: QuestionTypeCreateInput;
      update: QuestionTypeUpdateInput;
    }
  ) => QuestionTypePromise;
  deleteQuestionType: (
    where: QuestionTypeWhereUniqueInput
  ) => QuestionTypePromise;
  deleteManyQuestionTypes: (
    where?: QuestionTypeWhereInput
  ) => BatchPayloadPromise;
  createResponse: (data: ResponseCreateInput) => ResponsePromise;
  updateResponse: (
    args: { data: ResponseUpdateInput; where: ResponseWhereUniqueInput }
  ) => ResponsePromise;
  updateManyResponses: (
    args: { data: ResponseUpdateManyMutationInput; where?: ResponseWhereInput }
  ) => BatchPayloadPromise;
  upsertResponse: (
    args: {
      where: ResponseWhereUniqueInput;
      create: ResponseCreateInput;
      update: ResponseUpdateInput;
    }
  ) => ResponsePromise;
  deleteResponse: (where: ResponseWhereUniqueInput) => ResponsePromise;
  deleteManyResponses: (where?: ResponseWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserDiagnosis: (data: UserDiagnosisCreateInput) => UserDiagnosisPromise;
  updateUserDiagnosis: (
    args: {
      data: UserDiagnosisUpdateInput;
      where: UserDiagnosisWhereUniqueInput;
    }
  ) => UserDiagnosisPromise;
  updateManyUserDiagnoses: (
    args: {
      data: UserDiagnosisUpdateManyMutationInput;
      where?: UserDiagnosisWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserDiagnosis: (
    args: {
      where: UserDiagnosisWhereUniqueInput;
      create: UserDiagnosisCreateInput;
      update: UserDiagnosisUpdateInput;
    }
  ) => UserDiagnosisPromise;
  deleteUserDiagnosis: (
    where: UserDiagnosisWhereUniqueInput
  ) => UserDiagnosisPromise;
  deleteManyUserDiagnoses: (
    where?: UserDiagnosisWhereInput
  ) => BatchPayloadPromise;
  createUserResponse: (data: UserResponseCreateInput) => UserResponsePromise;
  updateUserResponse: (
    args: { data: UserResponseUpdateInput; where: UserResponseWhereUniqueInput }
  ) => UserResponsePromise;
  upsertUserResponse: (
    args: {
      where: UserResponseWhereUniqueInput;
      create: UserResponseCreateInput;
      update: UserResponseUpdateInput;
    }
  ) => UserResponsePromise;
  deleteUserResponse: (
    where: UserResponseWhereUniqueInput
  ) => UserResponsePromise;
  deleteManyUserResponses: (
    where?: UserResponseWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  cognitiveTest: (
    where?: CognitiveTestSubscriptionWhereInput
  ) => CognitiveTestSubscriptionPayloadSubscription;
  cognitiveTestQuestion: (
    where?: CognitiveTestQuestionSubscriptionWhereInput
  ) => CognitiveTestQuestionSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  forum: (
    where?: ForumSubscriptionWhereInput
  ) => ForumSubscriptionPayloadSubscription;
  questionType: (
    where?: QuestionTypeSubscriptionWhereInput
  ) => QuestionTypeSubscriptionPayloadSubscription;
  response: (
    where?: ResponseSubscriptionWhereInput
  ) => ResponseSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userDiagnosis: (
    where?: UserDiagnosisSubscriptionWhereInput
  ) => UserDiagnosisSubscriptionPayloadSubscription;
  userResponse: (
    where?: UserResponseSubscriptionWhereInput
  ) => UserResponseSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ForumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ResponseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "correct_ASC"
  | "correct_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserResponseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CognitiveTestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CognitiveTestQuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "question_ASC"
  | "question_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type QuestionTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "aidName_ASC"
  | "aidName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "address_ASC"
  | "address_DESC"
  | "birthDate_ASC"
  | "birthDate_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserDiagnosisOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "CognitiveResult_ASC"
  | "CognitiveResult_DESC"
  | "MusicalResult_ASC"
  | "MusicalResult_DESC"
  | "GamesResult_ASC"
  | "GamesResult_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface CognitiveTestQuestionUpdateDataInput {
  question?: String;
  active?: Boolean;
  type?: QuestionTypeUpdateOneWithoutQuestionsInput;
  responses?: ResponseUpdateManyWithoutQuestionInput;
}

export type CognitiveTestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserResponseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CommentCreateInput {
  text?: String;
  forum: ForumCreateOneWithoutCommentsInput;
  user: UserCreateOneInput;
}

export interface CommentUpdateManyMutationInput {
  text?: String;
}

export interface ResponseUpdateWithoutQuestionDataInput {
  correct?: Boolean;
  text?: String;
}

export interface ForumUpsertWithoutCommentsInput {
  update: ForumUpdateWithoutCommentsDataInput;
  create: ForumCreateWithoutCommentsInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  aidName?: String;
  aidName_not?: String;
  aidName_in?: String[] | String;
  aidName_not_in?: String[] | String;
  aidName_lt?: String;
  aidName_lte?: String;
  aidName_gt?: String;
  aidName_gte?: String;
  aidName_contains?: String;
  aidName_not_contains?: String;
  aidName_starts_with?: String;
  aidName_not_starts_with?: String;
  aidName_ends_with?: String;
  aidName_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  birthDate?: String;
  birthDate_not?: String;
  birthDate_in?: String[] | String;
  birthDate_not_in?: String[] | String;
  birthDate_lt?: String;
  birthDate_lte?: String;
  birthDate_gt?: String;
  birthDate_gte?: String;
  birthDate_contains?: String;
  birthDate_not_contains?: String;
  birthDate_starts_with?: String;
  birthDate_not_starts_with?: String;
  birthDate_ends_with?: String;
  birthDate_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ForumUpdateWithoutCommentsDataInput {
  text?: String;
  title?: String;
  user?: UserUpdateOneRequiredInput;
}

export interface UserDiagnosisSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserDiagnosisWhereInput;
  AND?:
    | UserDiagnosisSubscriptionWhereInput[]
    | UserDiagnosisSubscriptionWhereInput;
  OR?:
    | UserDiagnosisSubscriptionWhereInput[]
    | UserDiagnosisSubscriptionWhereInput;
  NOT?:
    | UserDiagnosisSubscriptionWhereInput[]
    | UserDiagnosisSubscriptionWhereInput;
}

export interface CognitiveTestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  questions_every?: CognitiveTestQuestionWhereInput;
  questions_some?: CognitiveTestQuestionWhereInput;
  questions_none?: CognitiveTestQuestionWhereInput;
  responses_every?: UserResponseWhereInput;
  responses_some?: UserResponseWhereInput;
  responses_none?: UserResponseWhereInput;
  User?: UserWhereInput;
  AND?: CognitiveTestWhereInput[] | CognitiveTestWhereInput;
  OR?: CognitiveTestWhereInput[] | CognitiveTestWhereInput;
  NOT?: CognitiveTestWhereInput[] | CognitiveTestWhereInput;
}

export interface QuestionTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: QuestionTypeWhereInput;
  AND?:
    | QuestionTypeSubscriptionWhereInput[]
    | QuestionTypeSubscriptionWhereInput;
  OR?:
    | QuestionTypeSubscriptionWhereInput[]
    | QuestionTypeSubscriptionWhereInput;
  NOT?:
    | QuestionTypeSubscriptionWhereInput[]
    | QuestionTypeSubscriptionWhereInput;
}

export interface CognitiveTestCreateInput {
  questions?: CognitiveTestQuestionCreateManyInput;
  responses?: UserResponseCreateManyInput;
  User: UserCreateOneInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface CognitiveTestQuestionCreateManyInput {
  create?:
    | CognitiveTestQuestionCreateInput[]
    | CognitiveTestQuestionCreateInput;
  connect?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
}

export type CognitiveTestQuestionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CognitiveTestQuestionCreateInput {
  question: String;
  active: Boolean;
  type?: QuestionTypeCreateOneWithoutQuestionsInput;
  responses?: ResponseCreateManyWithoutQuestionInput;
}

export interface UserResponseUpdateInput {
  question?: CognitiveTestQuestionUpdateOneRequiredInput;
  response?: ResponseUpdateOneRequiredInput;
  User?: UserUpdateOneRequiredInput;
}

export interface QuestionTypeCreateOneWithoutQuestionsInput {
  create?: QuestionTypeCreateWithoutQuestionsInput;
  connect?: QuestionTypeWhereUniqueInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface QuestionTypeCreateWithoutQuestionsInput {
  type: String;
}

export interface UserDiagnosisCreateInput {
  User: UserCreateOneInput;
  CognitiveResult: Float;
  MusicalResult: Float;
  GamesResult: Float;
}

export interface ResponseCreateManyWithoutQuestionInput {
  create?:
    | ResponseCreateWithoutQuestionInput[]
    | ResponseCreateWithoutQuestionInput;
  connect?: ResponseWhereUniqueInput[] | ResponseWhereUniqueInput;
}

export interface ForumWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  user?: UserWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  AND?: ForumWhereInput[] | ForumWhereInput;
  OR?: ForumWhereInput[] | ForumWhereInput;
  NOT?: ForumWhereInput[] | ForumWhereInput;
}

export interface ResponseCreateWithoutQuestionInput {
  correct: Boolean;
  text: String;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  email?: String;
  aidName?: String;
  phone?: String;
  address?: String;
  birthDate?: String;
  password?: String;
}

export interface UserResponseCreateManyInput {
  create?: UserResponseCreateInput[] | UserResponseCreateInput;
  connect?: UserResponseWhereUniqueInput[] | UserResponseWhereUniqueInput;
}

export interface ResponseUpdateManyMutationInput {
  correct?: Boolean;
  text?: String;
}

export interface UserResponseCreateInput {
  question: CognitiveTestQuestionCreateOneInput;
  response: ResponseCreateOneInput;
  User: UserCreateOneInput;
}

export interface QuestionTypeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  questions_every?: CognitiveTestQuestionWhereInput;
  questions_some?: CognitiveTestQuestionWhereInput;
  questions_none?: CognitiveTestQuestionWhereInput;
  AND?: QuestionTypeWhereInput[] | QuestionTypeWhereInput;
  OR?: QuestionTypeWhereInput[] | QuestionTypeWhereInput;
  NOT?: QuestionTypeWhereInput[] | QuestionTypeWhereInput;
}

export interface CognitiveTestQuestionCreateOneInput {
  create?: CognitiveTestQuestionCreateInput;
  connect?: CognitiveTestQuestionWhereUniqueInput;
}

export interface QuestionTypeUpdateManyMutationInput {
  type?: String;
}

export interface ResponseCreateOneInput {
  create?: ResponseCreateInput;
  connect?: ResponseWhereUniqueInput;
}

export type QuestionTypeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ResponseCreateInput {
  question: CognitiveTestQuestionCreateOneWithoutResponsesInput;
  correct: Boolean;
  text: String;
}

export interface CognitiveTestQuestionUpdateWithWhereUniqueWithoutTypeInput {
  where: CognitiveTestQuestionWhereUniqueInput;
  data: CognitiveTestQuestionUpdateWithoutTypeDataInput;
}

export interface CognitiveTestQuestionCreateOneWithoutResponsesInput {
  create?: CognitiveTestQuestionCreateWithoutResponsesInput;
  connect?: CognitiveTestQuestionWhereUniqueInput;
}

export interface QuestionTypeUpdateInput {
  type?: String;
  questions?: CognitiveTestQuestionUpdateManyWithoutTypeInput;
}

export interface CognitiveTestQuestionCreateWithoutResponsesInput {
  question: String;
  active: Boolean;
  type?: QuestionTypeCreateOneWithoutQuestionsInput;
}

export interface CognitiveTestQuestionCreateWithoutTypeInput {
  question: String;
  active: Boolean;
  responses?: ResponseCreateManyWithoutQuestionInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface QuestionTypeCreateInput {
  type: String;
  questions?: CognitiveTestQuestionCreateManyWithoutTypeInput;
}

export interface UserCreateInput {
  username: String;
  email: String;
  aidName: String;
  phone: String;
  address: String;
  birthDate: String;
  password: String;
}

export interface ForumUpdateManyMutationInput {
  text?: String;
  title?: String;
}

export interface CognitiveTestUpdateInput {
  questions?: CognitiveTestQuestionUpdateManyInput;
  responses?: UserResponseUpdateManyInput;
  User?: UserUpdateOneRequiredInput;
}

export interface CommentUpdateWithoutForumDataInput {
  text?: String;
  user?: UserUpdateOneRequiredInput;
}

export interface CognitiveTestQuestionUpdateManyInput {
  create?:
    | CognitiveTestQuestionCreateInput[]
    | CognitiveTestQuestionCreateInput;
  update?:
    | CognitiveTestQuestionUpdateWithWhereUniqueNestedInput[]
    | CognitiveTestQuestionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CognitiveTestQuestionUpsertWithWhereUniqueNestedInput[]
    | CognitiveTestQuestionUpsertWithWhereUniqueNestedInput;
  delete?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
  connect?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
  disconnect?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
}

export type UserDiagnosisWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CognitiveTestQuestionUpdateWithWhereUniqueNestedInput {
  where: CognitiveTestQuestionWhereUniqueInput;
  data: CognitiveTestQuestionUpdateDataInput;
}

export interface ForumUpdateInput {
  text?: String;
  title?: String;
  user?: UserUpdateOneRequiredInput;
  comments?: CommentUpdateManyWithoutForumInput;
}

export interface ForumUpdateOneRequiredWithoutCommentsInput {
  create?: ForumCreateWithoutCommentsInput;
  update?: ForumUpdateWithoutCommentsDataInput;
  upsert?: ForumUpsertWithoutCommentsInput;
  connect?: ForumWhereUniqueInput;
}

export interface CognitiveTestQuestionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  question?: String;
  question_not?: String;
  question_in?: String[] | String;
  question_not_in?: String[] | String;
  question_lt?: String;
  question_lte?: String;
  question_gt?: String;
  question_gte?: String;
  question_contains?: String;
  question_not_contains?: String;
  question_starts_with?: String;
  question_not_starts_with?: String;
  question_ends_with?: String;
  question_not_ends_with?: String;
  active?: Boolean;
  active_not?: Boolean;
  type?: QuestionTypeWhereInput;
  responses_every?: ResponseWhereInput;
  responses_some?: ResponseWhereInput;
  responses_none?: ResponseWhereInput;
  AND?: CognitiveTestQuestionWhereInput[] | CognitiveTestQuestionWhereInput;
  OR?: CognitiveTestQuestionWhereInput[] | CognitiveTestQuestionWhereInput;
  NOT?: CognitiveTestQuestionWhereInput[] | CognitiveTestQuestionWhereInput;
}

export interface QuestionTypeUpdateOneWithoutQuestionsInput {
  create?: QuestionTypeCreateWithoutQuestionsInput;
  update?: QuestionTypeUpdateWithoutQuestionsDataInput;
  upsert?: QuestionTypeUpsertWithoutQuestionsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: QuestionTypeWhereUniqueInput;
}

export interface CommentCreateManyWithoutForumInput {
  create?: CommentCreateWithoutForumInput[] | CommentCreateWithoutForumInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface QuestionTypeUpdateWithoutQuestionsDataInput {
  type?: String;
}

export interface UserResponseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  question?: CognitiveTestQuestionWhereInput;
  response?: ResponseWhereInput;
  User?: UserWhereInput;
  AND?: UserResponseWhereInput[] | UserResponseWhereInput;
  OR?: UserResponseWhereInput[] | UserResponseWhereInput;
  NOT?: UserResponseWhereInput[] | UserResponseWhereInput;
}

export interface QuestionTypeUpsertWithoutQuestionsInput {
  update: QuestionTypeUpdateWithoutQuestionsDataInput;
  create: QuestionTypeCreateWithoutQuestionsInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ResponseUpdateManyWithoutQuestionInput {
  create?:
    | ResponseCreateWithoutQuestionInput[]
    | ResponseCreateWithoutQuestionInput;
  delete?: ResponseWhereUniqueInput[] | ResponseWhereUniqueInput;
  connect?: ResponseWhereUniqueInput[] | ResponseWhereUniqueInput;
  disconnect?: ResponseWhereUniqueInput[] | ResponseWhereUniqueInput;
  update?:
    | ResponseUpdateWithWhereUniqueWithoutQuestionInput[]
    | ResponseUpdateWithWhereUniqueWithoutQuestionInput;
  upsert?:
    | ResponseUpsertWithWhereUniqueWithoutQuestionInput[]
    | ResponseUpsertWithWhereUniqueWithoutQuestionInput;
}

export interface ForumSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ForumWhereInput;
  AND?: ForumSubscriptionWhereInput[] | ForumSubscriptionWhereInput;
  OR?: ForumSubscriptionWhereInput[] | ForumSubscriptionWhereInput;
  NOT?: ForumSubscriptionWhereInput[] | ForumSubscriptionWhereInput;
}

export interface ResponseUpdateWithWhereUniqueWithoutQuestionInput {
  where: ResponseWhereUniqueInput;
  data: ResponseUpdateWithoutQuestionDataInput;
}

export interface CognitiveTestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CognitiveTestWhereInput;
  AND?:
    | CognitiveTestSubscriptionWhereInput[]
    | CognitiveTestSubscriptionWhereInput;
  OR?:
    | CognitiveTestSubscriptionWhereInput[]
    | CognitiveTestSubscriptionWhereInput;
  NOT?:
    | CognitiveTestSubscriptionWhereInput[]
    | CognitiveTestSubscriptionWhereInput;
}

export interface CommentUpdateInput {
  text?: String;
  forum?: ForumUpdateOneRequiredWithoutCommentsInput;
  user?: UserUpdateOneRequiredInput;
}

export interface UserDiagnosisUpdateInput {
  User?: UserUpdateOneRequiredInput;
  CognitiveResult?: Float;
  MusicalResult?: Float;
  GamesResult?: Float;
}

export interface ResponseUpsertWithWhereUniqueWithoutQuestionInput {
  where: ResponseWhereUniqueInput;
  update: ResponseUpdateWithoutQuestionDataInput;
  create: ResponseCreateWithoutQuestionInput;
}

export interface ResponseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  question?: CognitiveTestQuestionWhereInput;
  correct?: Boolean;
  correct_not?: Boolean;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: ResponseWhereInput[] | ResponseWhereInput;
  OR?: ResponseWhereInput[] | ResponseWhereInput;
  NOT?: ResponseWhereInput[] | ResponseWhereInput;
}

export interface CognitiveTestQuestionUpsertWithWhereUniqueNestedInput {
  where: CognitiveTestQuestionWhereUniqueInput;
  update: CognitiveTestQuestionUpdateDataInput;
  create: CognitiveTestQuestionCreateInput;
}

export type ForumWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserResponseUpdateManyInput {
  create?: UserResponseCreateInput[] | UserResponseCreateInput;
  update?:
    | UserResponseUpdateWithWhereUniqueNestedInput[]
    | UserResponseUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserResponseUpsertWithWhereUniqueNestedInput[]
    | UserResponseUpsertWithWhereUniqueNestedInput;
  delete?: UserResponseWhereUniqueInput[] | UserResponseWhereUniqueInput;
  connect?: UserResponseWhereUniqueInput[] | UserResponseWhereUniqueInput;
  disconnect?: UserResponseWhereUniqueInput[] | UserResponseWhereUniqueInput;
}

export interface CognitiveTestQuestionUpsertWithWhereUniqueWithoutTypeInput {
  where: CognitiveTestQuestionWhereUniqueInput;
  update: CognitiveTestQuestionUpdateWithoutTypeDataInput;
  create: CognitiveTestQuestionCreateWithoutTypeInput;
}

export interface UserResponseUpdateWithWhereUniqueNestedInput {
  where: UserResponseWhereUniqueInput;
  data: UserResponseUpdateDataInput;
}

export interface CognitiveTestQuestionUpdateManyWithoutTypeInput {
  create?:
    | CognitiveTestQuestionCreateWithoutTypeInput[]
    | CognitiveTestQuestionCreateWithoutTypeInput;
  delete?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
  connect?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
  disconnect?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
  update?:
    | CognitiveTestQuestionUpdateWithWhereUniqueWithoutTypeInput[]
    | CognitiveTestQuestionUpdateWithWhereUniqueWithoutTypeInput;
  upsert?:
    | CognitiveTestQuestionUpsertWithWhereUniqueWithoutTypeInput[]
    | CognitiveTestQuestionUpsertWithWhereUniqueWithoutTypeInput;
}

export interface UserResponseUpdateDataInput {
  question?: CognitiveTestQuestionUpdateOneRequiredInput;
  response?: ResponseUpdateOneRequiredInput;
  User?: UserUpdateOneRequiredInput;
}

export interface CognitiveTestQuestionCreateManyWithoutTypeInput {
  create?:
    | CognitiveTestQuestionCreateWithoutTypeInput[]
    | CognitiveTestQuestionCreateWithoutTypeInput;
  connect?:
    | CognitiveTestQuestionWhereUniqueInput[]
    | CognitiveTestQuestionWhereUniqueInput;
}

export interface CognitiveTestQuestionUpdateOneRequiredInput {
  create?: CognitiveTestQuestionCreateInput;
  update?: CognitiveTestQuestionUpdateDataInput;
  upsert?: CognitiveTestQuestionUpsertNestedInput;
  connect?: CognitiveTestQuestionWhereUniqueInput;
}

export interface CommentUpsertWithWhereUniqueWithoutForumInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutForumDataInput;
  create: CommentCreateWithoutForumInput;
}

export interface CognitiveTestQuestionUpsertNestedInput {
  update: CognitiveTestQuestionUpdateDataInput;
  create: CognitiveTestQuestionCreateInput;
}

export interface CommentUpdateManyWithoutForumInput {
  create?: CommentCreateWithoutForumInput[] | CommentCreateWithoutForumInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutForumInput[]
    | CommentUpdateWithWhereUniqueWithoutForumInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutForumInput[]
    | CommentUpsertWithWhereUniqueWithoutForumInput;
}

export interface ResponseUpdateOneRequiredInput {
  create?: ResponseCreateInput;
  update?: ResponseUpdateDataInput;
  upsert?: ResponseUpsertNestedInput;
  connect?: ResponseWhereUniqueInput;
}

export interface CommentCreateWithoutForumInput {
  text?: String;
  user: UserCreateOneInput;
}

export interface ResponseUpdateDataInput {
  question?: CognitiveTestQuestionUpdateOneRequiredWithoutResponsesInput;
  correct?: Boolean;
  text?: String;
}

export interface UserResponseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserResponseWhereInput;
  AND?:
    | UserResponseSubscriptionWhereInput[]
    | UserResponseSubscriptionWhereInput;
  OR?:
    | UserResponseSubscriptionWhereInput[]
    | UserResponseSubscriptionWhereInput;
  NOT?:
    | UserResponseSubscriptionWhereInput[]
    | UserResponseSubscriptionWhereInput;
}

export interface CognitiveTestQuestionUpdateOneRequiredWithoutResponsesInput {
  create?: CognitiveTestQuestionCreateWithoutResponsesInput;
  update?: CognitiveTestQuestionUpdateWithoutResponsesDataInput;
  upsert?: CognitiveTestQuestionUpsertWithoutResponsesInput;
  connect?: CognitiveTestQuestionWhereUniqueInput;
}

export interface CognitiveTestQuestionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CognitiveTestQuestionWhereInput;
  AND?:
    | CognitiveTestQuestionSubscriptionWhereInput[]
    | CognitiveTestQuestionSubscriptionWhereInput;
  OR?:
    | CognitiveTestQuestionSubscriptionWhereInput[]
    | CognitiveTestQuestionSubscriptionWhereInput;
  NOT?:
    | CognitiveTestQuestionSubscriptionWhereInput[]
    | CognitiveTestQuestionSubscriptionWhereInput;
}

export interface CognitiveTestQuestionUpdateWithoutResponsesDataInput {
  question?: String;
  active?: Boolean;
  type?: QuestionTypeUpdateOneWithoutQuestionsInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  forum?: ForumWhereInput;
  user?: UserWhereInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface CognitiveTestQuestionUpsertWithoutResponsesInput {
  update: CognitiveTestQuestionUpdateWithoutResponsesDataInput;
  create: CognitiveTestQuestionCreateWithoutResponsesInput;
}

export interface ResponseUpdateInput {
  question?: CognitiveTestQuestionUpdateOneRequiredWithoutResponsesInput;
  correct?: Boolean;
  text?: String;
}

export interface ResponseUpsertNestedInput {
  update: ResponseUpdateDataInput;
  create: ResponseCreateInput;
}

export type ResponseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface CommentUpdateWithWhereUniqueWithoutForumInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutForumDataInput;
}

export interface UserUpdateDataInput {
  username?: String;
  email?: String;
  aidName?: String;
  phone?: String;
  address?: String;
  birthDate?: String;
  password?: String;
}

export interface ForumCreateInput {
  text?: String;
  title?: String;
  user: UserCreateOneInput;
  comments?: CommentCreateManyWithoutForumInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserDiagnosisUpdateManyMutationInput {
  CognitiveResult?: Float;
  MusicalResult?: Float;
  GamesResult?: Float;
}

export interface UserResponseUpsertWithWhereUniqueNestedInput {
  where: UserResponseWhereUniqueInput;
  update: UserResponseUpdateDataInput;
  create: UserResponseCreateInput;
}

export interface CognitiveTestQuestionUpdateWithoutTypeDataInput {
  question?: String;
  active?: Boolean;
  responses?: ResponseUpdateManyWithoutQuestionInput;
}

export interface CognitiveTestQuestionUpdateManyMutationInput {
  question?: String;
  active?: Boolean;
}

export interface CognitiveTestQuestionUpdateInput {
  question?: String;
  active?: Boolean;
  type?: QuestionTypeUpdateOneWithoutQuestionsInput;
  responses?: ResponseUpdateManyWithoutQuestionInput;
}

export interface ForumCreateOneWithoutCommentsInput {
  create?: ForumCreateWithoutCommentsInput;
  connect?: ForumWhereUniqueInput;
}

export interface ForumCreateWithoutCommentsInput {
  text?: String;
  title?: String;
  user: UserCreateOneInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateInput {
  username?: String;
  email?: String;
  aidName?: String;
  phone?: String;
  address?: String;
  birthDate?: String;
  password?: String;
}

export interface ResponseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ResponseWhereInput;
  AND?: ResponseSubscriptionWhereInput[] | ResponseSubscriptionWhereInput;
  OR?: ResponseSubscriptionWhereInput[] | ResponseSubscriptionWhereInput;
  NOT?: ResponseSubscriptionWhereInput[] | ResponseSubscriptionWhereInput;
}

export interface UserDiagnosisWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  User?: UserWhereInput;
  CognitiveResult?: Float;
  CognitiveResult_not?: Float;
  CognitiveResult_in?: Float[] | Float;
  CognitiveResult_not_in?: Float[] | Float;
  CognitiveResult_lt?: Float;
  CognitiveResult_lte?: Float;
  CognitiveResult_gt?: Float;
  CognitiveResult_gte?: Float;
  MusicalResult?: Float;
  MusicalResult_not?: Float;
  MusicalResult_in?: Float[] | Float;
  MusicalResult_not_in?: Float[] | Float;
  MusicalResult_lt?: Float;
  MusicalResult_lte?: Float;
  MusicalResult_gt?: Float;
  MusicalResult_gte?: Float;
  GamesResult?: Float;
  GamesResult_not?: Float;
  GamesResult_in?: Float[] | Float;
  GamesResult_not_in?: Float[] | Float;
  GamesResult_lt?: Float;
  GamesResult_lte?: Float;
  GamesResult_gt?: Float;
  GamesResult_gte?: Float;
  AND?: UserDiagnosisWhereInput[] | UserDiagnosisWhereInput;
  OR?: UserDiagnosisWhereInput[] | UserDiagnosisWhereInput;
  NOT?: UserDiagnosisWhereInput[] | UserDiagnosisWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserResponsePreviousValues {
  id: ID_Output;
}

export interface UserResponsePreviousValuesPromise
  extends Promise<UserResponsePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface UserResponsePreviousValuesSubscription
  extends Promise<AsyncIterator<UserResponsePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Comment {
  id: ID_Output;
  text?: String;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  forum: <T = Forum>() => T;
  user: <T = User>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  forum: <T = ForumSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface QuestionType {
  id: ID_Output;
  type: String;
}

export interface QuestionTypePromise
  extends Promise<QuestionType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  questions: <T = FragmentableArray<CognitiveTestQuestion>>(
    args?: {
      where?: CognitiveTestQuestionWhereInput;
      orderBy?: CognitiveTestQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface QuestionTypeSubscription
  extends Promise<AsyncIterator<QuestionType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  questions: <T = Promise<AsyncIterator<CognitiveTestQuestionSubscription>>>(
    args?: {
      where?: CognitiveTestQuestionWhereInput;
      orderBy?: CognitiveTestQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateCognitiveTestQuestion {
  count: Int;
}

export interface AggregateCognitiveTestQuestionPromise
  extends Promise<AggregateCognitiveTestQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCognitiveTestQuestionSubscription
  extends Promise<AsyncIterator<AggregateCognitiveTestQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Response {
  id: ID_Output;
  correct: Boolean;
  text: String;
}

export interface ResponsePromise extends Promise<Response>, Fragmentable {
  id: () => Promise<ID_Output>;
  question: <T = CognitiveTestQuestion>() => T;
  correct: () => Promise<Boolean>;
  text: () => Promise<String>;
}

export interface ResponseSubscription
  extends Promise<AsyncIterator<Response>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: <T = CognitiveTestQuestionSubscription>() => T;
  correct: () => Promise<AsyncIterator<Boolean>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface CognitiveTestQuestionEdge {
  cursor: String;
}

export interface CognitiveTestQuestionEdgePromise
  extends Promise<CognitiveTestQuestionEdge>,
    Fragmentable {
  node: <T = CognitiveTestQuestion>() => T;
  cursor: () => Promise<String>;
}

export interface CognitiveTestQuestionEdgeSubscription
  extends Promise<AsyncIterator<CognitiveTestQuestionEdge>>,
    Fragmentable {
  node: <T = CognitiveTestQuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserResponse {
  count: Int;
}

export interface AggregateUserResponsePromise
  extends Promise<AggregateUserResponse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserResponseSubscription
  extends Promise<AsyncIterator<AggregateUserResponse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CognitiveTestQuestionConnection {}

export interface CognitiveTestQuestionConnectionPromise
  extends Promise<CognitiveTestQuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CognitiveTestQuestionEdge>>() => T;
  aggregate: <T = AggregateCognitiveTestQuestion>() => T;
}

export interface CognitiveTestQuestionConnectionSubscription
  extends Promise<AsyncIterator<CognitiveTestQuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CognitiveTestQuestionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCognitiveTestQuestionSubscription>() => T;
}

export interface UserResponseConnection {}

export interface UserResponseConnectionPromise
  extends Promise<UserResponseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserResponseEdge>>() => T;
  aggregate: <T = AggregateUserResponse>() => T;
}

export interface UserResponseConnectionSubscription
  extends Promise<AsyncIterator<UserResponseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserResponseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserResponseSubscription>() => T;
}

export interface CognitiveTest {
  id: ID_Output;
}

export interface CognitiveTestPromise
  extends Promise<CognitiveTest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  questions: <T = FragmentableArray<CognitiveTestQuestion>>(
    args?: {
      where?: CognitiveTestQuestionWhereInput;
      orderBy?: CognitiveTestQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  responses: <T = FragmentableArray<UserResponse>>(
    args?: {
      where?: UserResponseWhereInput;
      orderBy?: UserResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  User: <T = User>() => T;
}

export interface CognitiveTestSubscription
  extends Promise<AsyncIterator<CognitiveTest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  questions: <T = Promise<AsyncIterator<CognitiveTestQuestionSubscription>>>(
    args?: {
      where?: CognitiveTestQuestionWhereInput;
      orderBy?: CognitiveTestQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  responses: <T = Promise<AsyncIterator<UserResponseSubscription>>>(
    args?: {
      where?: UserResponseWhereInput;
      orderBy?: UserResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  User: <T = UserSubscription>() => T;
}

export interface UserDiagnosisEdge {
  cursor: String;
}

export interface UserDiagnosisEdgePromise
  extends Promise<UserDiagnosisEdge>,
    Fragmentable {
  node: <T = UserDiagnosis>() => T;
  cursor: () => Promise<String>;
}

export interface UserDiagnosisEdgeSubscription
  extends Promise<AsyncIterator<UserDiagnosisEdge>>,
    Fragmentable {
  node: <T = UserDiagnosisSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserDiagnosis {
  count: Int;
}

export interface AggregateUserDiagnosisPromise
  extends Promise<AggregateUserDiagnosis>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserDiagnosisSubscription
  extends Promise<AsyncIterator<AggregateUserDiagnosis>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserResponse {
  id: ID_Output;
}

export interface UserResponsePromise
  extends Promise<UserResponse>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  question: <T = CognitiveTestQuestion>() => T;
  response: <T = Response>() => T;
  User: <T = User>() => T;
}

export interface UserResponseSubscription
  extends Promise<AsyncIterator<UserResponse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: <T = CognitiveTestQuestionSubscription>() => T;
  response: <T = ResponseSubscription>() => T;
  User: <T = UserSubscription>() => T;
}

export interface UserDiagnosisConnection {}

export interface UserDiagnosisConnectionPromise
  extends Promise<UserDiagnosisConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserDiagnosisEdge>>() => T;
  aggregate: <T = AggregateUserDiagnosis>() => T;
}

export interface UserDiagnosisConnectionSubscription
  extends Promise<AsyncIterator<UserDiagnosisConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserDiagnosisEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserDiagnosisSubscription>() => T;
}

export interface CognitiveTestSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CognitiveTestSubscriptionPayloadPromise
  extends Promise<CognitiveTestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CognitiveTest>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CognitiveTestPreviousValues>() => T;
}

export interface CognitiveTestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CognitiveTestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CognitiveTestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CognitiveTestPreviousValuesSubscription>() => T;
}

export interface UserDiagnosis {
  id: ID_Output;
  CognitiveResult: Float;
  MusicalResult: Float;
  GamesResult: Float;
}

export interface UserDiagnosisPromise
  extends Promise<UserDiagnosis>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  User: <T = User>() => T;
  CognitiveResult: () => Promise<Float>;
  MusicalResult: () => Promise<Float>;
  GamesResult: () => Promise<Float>;
}

export interface UserDiagnosisSubscription
  extends Promise<AsyncIterator<UserDiagnosis>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  User: <T = UserSubscription>() => T;
  CognitiveResult: () => Promise<AsyncIterator<Float>>;
  MusicalResult: () => Promise<AsyncIterator<Float>>;
  GamesResult: () => Promise<AsyncIterator<Float>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CognitiveTestPreviousValues {
  id: ID_Output;
}

export interface CognitiveTestPreviousValuesPromise
  extends Promise<CognitiveTestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CognitiveTestPreviousValuesSubscription
  extends Promise<AsyncIterator<CognitiveTestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserResponseSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserResponseSubscriptionPayloadPromise
  extends Promise<UserResponseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserResponse>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserResponsePreviousValues>() => T;
}

export interface UserResponseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserResponseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserResponseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserResponsePreviousValuesSubscription>() => T;
}

export interface AggregateCognitiveTest {
  count: Int;
}

export interface AggregateCognitiveTestPromise
  extends Promise<AggregateCognitiveTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCognitiveTestSubscription
  extends Promise<AsyncIterator<AggregateCognitiveTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ResponseEdge {
  cursor: String;
}

export interface ResponseEdgePromise
  extends Promise<ResponseEdge>,
    Fragmentable {
  node: <T = Response>() => T;
  cursor: () => Promise<String>;
}

export interface ResponseEdgeSubscription
  extends Promise<AsyncIterator<ResponseEdge>>,
    Fragmentable {
  node: <T = ResponseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CognitiveTestQuestionSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CognitiveTestQuestionSubscriptionPayloadPromise
  extends Promise<CognitiveTestQuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CognitiveTestQuestion>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CognitiveTestQuestionPreviousValues>() => T;
}

export interface CognitiveTestQuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CognitiveTestQuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CognitiveTestQuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CognitiveTestQuestionPreviousValuesSubscription>() => T;
}

export interface AggregateQuestionType {
  count: Int;
}

export interface AggregateQuestionTypePromise
  extends Promise<AggregateQuestionType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionTypeSubscription
  extends Promise<AsyncIterator<AggregateQuestionType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CognitiveTestQuestionPreviousValues {
  id: ID_Output;
  question: String;
  active: Boolean;
}

export interface CognitiveTestQuestionPreviousValuesPromise
  extends Promise<CognitiveTestQuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  question: () => Promise<String>;
  active: () => Promise<Boolean>;
}

export interface CognitiveTestQuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<CognitiveTestQuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface QuestionTypeConnection {}

export interface QuestionTypeConnectionPromise
  extends Promise<QuestionTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<QuestionTypeEdge>>() => T;
  aggregate: <T = AggregateQuestionType>() => T;
}

export interface QuestionTypeConnectionSubscription
  extends Promise<AsyncIterator<QuestionTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionTypeSubscription>() => T;
}

export interface CognitiveTestEdge {
  cursor: String;
}

export interface CognitiveTestEdgePromise
  extends Promise<CognitiveTestEdge>,
    Fragmentable {
  node: <T = CognitiveTest>() => T;
  cursor: () => Promise<String>;
}

export interface CognitiveTestEdgeSubscription
  extends Promise<AsyncIterator<CognitiveTestEdge>>,
    Fragmentable {
  node: <T = CognitiveTestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateForum {
  count: Int;
}

export interface AggregateForumPromise
  extends Promise<AggregateForum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateForumSubscription
  extends Promise<AsyncIterator<AggregateForum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Comment>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValues>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface ForumConnection {}

export interface ForumConnectionPromise
  extends Promise<ForumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ForumEdge>>() => T;
  aggregate: <T = AggregateForum>() => T;
}

export interface ForumConnectionSubscription
  extends Promise<AsyncIterator<ForumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ForumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateForumSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text?: String;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface CommentEdge {
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = Comment>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Forum {
  id: ID_Output;
  text?: String;
  title?: String;
}

export interface ForumPromise extends Promise<Forum>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  title: () => Promise<String>;
  user: <T = User>() => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ForumSubscription
  extends Promise<AsyncIterator<Forum>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ForumSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ForumSubscriptionPayloadPromise
  extends Promise<ForumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Forum>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ForumPreviousValues>() => T;
}

export interface ForumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ForumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ForumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ForumPreviousValuesSubscription>() => T;
}

export interface UserDiagnosisPreviousValues {
  id: ID_Output;
  CognitiveResult: Float;
  MusicalResult: Float;
  GamesResult: Float;
}

export interface UserDiagnosisPreviousValuesPromise
  extends Promise<UserDiagnosisPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  CognitiveResult: () => Promise<Float>;
  MusicalResult: () => Promise<Float>;
  GamesResult: () => Promise<Float>;
}

export interface UserDiagnosisPreviousValuesSubscription
  extends Promise<AsyncIterator<UserDiagnosisPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  CognitiveResult: () => Promise<AsyncIterator<Float>>;
  MusicalResult: () => Promise<AsyncIterator<Float>>;
  GamesResult: () => Promise<AsyncIterator<Float>>;
}

export interface ForumPreviousValues {
  id: ID_Output;
  text?: String;
  title?: String;
}

export interface ForumPreviousValuesPromise
  extends Promise<ForumPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  title: () => Promise<String>;
}

export interface ForumPreviousValuesSubscription
  extends Promise<AsyncIterator<ForumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CognitiveTestConnection {}

export interface CognitiveTestConnectionPromise
  extends Promise<CognitiveTestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CognitiveTestEdge>>() => T;
  aggregate: <T = AggregateCognitiveTest>() => T;
}

export interface CognitiveTestConnectionSubscription
  extends Promise<AsyncIterator<CognitiveTestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CognitiveTestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCognitiveTestSubscription>() => T;
}

export interface AggregateResponse {
  count: Int;
}

export interface AggregateResponsePromise
  extends Promise<AggregateResponse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResponseSubscription
  extends Promise<AsyncIterator<AggregateResponse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionTypeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface QuestionTypeSubscriptionPayloadPromise
  extends Promise<QuestionTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionType>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionTypePreviousValues>() => T;
}

export interface QuestionTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionTypePreviousValuesSubscription>() => T;
}

export interface QuestionTypeEdge {
  cursor: String;
}

export interface QuestionTypeEdgePromise
  extends Promise<QuestionTypeEdge>,
    Fragmentable {
  node: <T = QuestionType>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionTypeEdgeSubscription
  extends Promise<AsyncIterator<QuestionTypeEdge>>,
    Fragmentable {
  node: <T = QuestionTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionTypePreviousValues {
  id: ID_Output;
  type: String;
}

export interface QuestionTypePreviousValuesPromise
  extends Promise<QuestionTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
}

export interface QuestionTypePreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface ForumEdge {
  cursor: String;
}

export interface ForumEdgePromise extends Promise<ForumEdge>, Fragmentable {
  node: <T = Forum>() => T;
  cursor: () => Promise<String>;
}

export interface ForumEdgeSubscription
  extends Promise<AsyncIterator<ForumEdge>>,
    Fragmentable {
  node: <T = ForumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserDiagnosisSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserDiagnosisSubscriptionPayloadPromise
  extends Promise<UserDiagnosisSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserDiagnosis>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserDiagnosisPreviousValues>() => T;
}

export interface UserDiagnosisSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserDiagnosisSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserDiagnosisSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserDiagnosisPreviousValuesSubscription>() => T;
}

export interface CommentConnection {}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateComment>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface ResponseSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ResponseSubscriptionPayloadPromise
  extends Promise<ResponseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Response>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResponsePreviousValues>() => T;
}

export interface ResponseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResponseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResponseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResponsePreviousValuesSubscription>() => T;
}

export interface UserResponseEdge {
  cursor: String;
}

export interface UserResponseEdgePromise
  extends Promise<UserResponseEdge>,
    Fragmentable {
  node: <T = UserResponse>() => T;
  cursor: () => Promise<String>;
}

export interface UserResponseEdgeSubscription
  extends Promise<AsyncIterator<UserResponseEdge>>,
    Fragmentable {
  node: <T = UserResponseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ResponseConnection {}

export interface ResponseConnectionPromise
  extends Promise<ResponseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ResponseEdge>>() => T;
  aggregate: <T = AggregateResponse>() => T;
}

export interface ResponseConnectionSubscription
  extends Promise<AsyncIterator<ResponseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResponseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResponseSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  email: String;
  aidName: String;
  phone: String;
  address: String;
  birthDate: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  aidName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  birthDate: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  aidName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  birthDate: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  username: String;
  email: String;
  aidName: String;
  phone: String;
  address: String;
  birthDate: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  aidName: () => Promise<String>;
  phone: () => Promise<String>;
  address: () => Promise<String>;
  birthDate: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  aidName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  birthDate: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface ResponsePreviousValues {
  id: ID_Output;
  correct: Boolean;
  text: String;
}

export interface ResponsePreviousValuesPromise
  extends Promise<ResponsePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  correct: () => Promise<Boolean>;
  text: () => Promise<String>;
}

export interface ResponsePreviousValuesSubscription
  extends Promise<AsyncIterator<ResponsePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  correct: () => Promise<AsyncIterator<Boolean>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface CognitiveTestQuestion {
  id: ID_Output;
  question: String;
  active: Boolean;
}

export interface CognitiveTestQuestionPromise
  extends Promise<CognitiveTestQuestion>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  question: () => Promise<String>;
  active: () => Promise<Boolean>;
  type: <T = QuestionType>() => T;
  responses: <T = FragmentableArray<Response>>(
    args?: {
      where?: ResponseWhereInput;
      orderBy?: ResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CognitiveTestQuestionSubscription
  extends Promise<AsyncIterator<CognitiveTestQuestion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  type: <T = QuestionTypeSubscription>() => T;
  responses: <T = Promise<AsyncIterator<ResponseSubscription>>>(
    args?: {
      where?: ResponseWhereInput;
      orderBy?: ResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "CognitiveTest",
    embedded: false
  },
  {
    name: "CognitiveTestQuestion",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Forum",
    embedded: false
  },
  {
    name: "QuestionType",
    embedded: false
  },
  {
    name: "Response",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserDiagnosis",
    embedded: false
  },
  {
    name: "UserResponse",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/alejox31-67c020/prisma-demo/dev`,
  secret: `mysecret123`
});
export const prisma = new Prisma();
